import{_ as a,c as n,o as e,ag as i}from"./chunks/framework.7BqJGZTL.js";const b=JSON.parse('{"title":"令牌刷新与失效","description":"","frontmatter":{},"headers":[],"relativePath":"安全考虑/认证与授权/令牌生成与验证/令牌刷新与失效.md","filePath":"安全考虑/认证与授权/令牌生成与验证/令牌刷新与失效.md","lastUpdated":1764244560000}'),p={name:"安全考虑/认证与授权/令牌生成与验证/令牌刷新与失效.md"};function l(t,s,r,h,c,E){return e(),n("div",null,[...s[0]||(s[0]=[i(`<h1 id="令牌刷新与失效" tabindex="-1">令牌刷新与失效 <a class="header-anchor" href="#令牌刷新与失效" aria-label="Permalink to &quot;令牌刷新与失效&quot;">​</a></h1><cite> **本文档引用的文件** - [user.py](https://github.com/Shy2593666979/AgentChat/src/backend/agentchat/api/v1/user.py) - [user.py](https://github.com/Shy2593666979/AgentChat/src/backend/agentchat/api/services/user.py) - [redis.py](https://github.com/Shy2593666979/AgentChat/src/backend/agentchat/services/redis.py) - [constants.py](https://github.com/Shy2593666979/AgentChat/src/backend/agentchat/utils/constants.py) - [JWT.py](https://github.com/Shy2593666979/AgentChat/src/backend/agentchat/utils/JWT.py) - [auth_jwt.py](https://github.com/Shy2593666979/AgentChat/src/backend/fastapi_jwt_auth/auth_jwt.py) </cite><h2 id="目录" tabindex="-1">目录 <a class="header-anchor" href="#目录" aria-label="Permalink to &quot;目录&quot;">​</a></h2><ol><li><a href="#引言">引言</a></li><li><a href="#令牌刷新机制">令牌刷新机制</a></li><li><a href="#服务端令牌状态跟踪与失效管理">服务端令牌状态跟踪与失效管理</a></li><li><a href="#混合认证模式分析">混合认证模式分析</a></li><li><a href="#系统架构影响">系统架构影响</a></li></ol><h2 id="引言" tabindex="-1">引言 <a class="header-anchor" href="#引言" aria-label="Permalink to &quot;引言&quot;">​</a></h2><p>AgentChat系统采用基于JWT（JSON Web Token）的认证机制，结合Redis缓存实现服务端的令牌状态管理。该系统通过访问令牌（access_token）和刷新令牌（refresh_token）的组合，实现了安全的用户会话管理。本文档将深入分析其令牌刷新与失效管理策略，重点阐述如何通过Redis缓存弥补无状态JWT在主动失效方面的不足。</p><h2 id="令牌刷新机制" tabindex="-1">令牌刷新机制 <a class="header-anchor" href="#令牌刷新机制" aria-label="Permalink to &quot;令牌刷新机制&quot;">​</a></h2><p>AgentChat系统实现了标准的双令牌认证模式。当用户成功登录后，系统会生成一对JWT令牌：短期有效的访问令牌和长期有效的刷新令牌。访问令牌用于访问受保护的API资源，而刷新令牌则用于在访问令牌过期后获取新的访问令牌，从而避免用户频繁重新登录。</p><p>系统通过<code>fastapi-jwt-auth</code>库提供的<code>create_access_token</code>和<code>create_refresh_token</code>方法生成令牌。根据代码分析，访问令牌的默认有效期为86400秒（24小时），而刷新令牌的默认有效期为30天。这两个令牌均通过<code>set_access_cookies</code>和<code>set_refresh_cookies</code>方法以HTTP Only Cookie的形式安全地发送给客户端，有效防止了XSS攻击。</p><p>尽管代码库中未直接实现刷新端点，但其设计意图清晰：当客户端检测到访问令牌过期时，应使用存储在Cookie中的刷新令牌向一个（未在当前代码中展示的）刷新端点发起请求。该端点将验证刷新令牌的有效性，并返回新的访问令牌，从而实现无缝的会话续期。</p><p><strong>Section sources</strong></p><ul><li><a href="https://github.com/Shy2593666979/AgentChat/src/backend/fastapi_jwt_auth/auth_jwt.py#L254-L305" target="_blank" rel="noreferrer">auth_jwt.py</a></li><li><a href="https://github.com/Shy2593666979/AgentChat/src/backend/agentchat/api/services/user.py#L152-L154" target="_blank" rel="noreferrer">user.py</a></li><li><a href="https://github.com/Shy2593666979/AgentChat/src/backend/agentchat/utils/JWT.py#L7" target="_blank" rel="noreferrer">JWT.py</a></li></ul><h2 id="服务端令牌状态跟踪与失效管理" tabindex="-1">服务端令牌状态跟踪与失效管理 <a class="header-anchor" href="#服务端令牌状态跟踪与失效管理" aria-label="Permalink to &quot;服务端令牌状态跟踪与失效管理&quot;">​</a></h2><p>为解决无状态JWT无法主动失效的问题，AgentChat系统采用了一种混合模式，在无状态的JWT之上叠加了有状态的Redis缓存层。其核心策略是：在用户登录后，将访问令牌的副本存储在Redis中，并设置比JWT本身长一小时的过期时间。</p><p>具体实现如下：在用户登录的<code>/user/login</code>接口中，除了生成并设置JWT Cookie外，系统还会执行<code>redis_client.set(USER_CURRENT_SESSION.format(db_user.user_id), access_token, ACCESS_TOKEN_EXPIRE_TIME + 3600)</code>。这里的<code>USER_CURRENT_SESSION</code>是一个格式化字符串<code>&#39;user_current_session:{}&#39;</code>，用于为每个用户创建唯一的Redis键。例如，用户ID为&quot;123&quot;的用户，其Redis键为<code>user_current_session:123</code>。</p><p>此设计的关键在于Redis的过期时间（<code>ACCESS_TOKEN_EXPIRE_TIME + 3600</code>）比JWT的过期时间（<code>ACCESS_TOKEN_EXPIRE_TIME</code>）多出3600秒（1小时）。这意味着，即使JWT本身尚未过期，只要Redis中的记录被删除，该令牌在服务端就会被视为无效。这为实现用户登出和强制令牌失效提供了可能。</p><div class="language-mermaid vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">mermaid</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">sequenceDiagram</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    participant Client as 客户端</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    participant API as API服务器</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    participant Redis as Redis缓存</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    </span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    Client-&gt;&gt;API: POST /user/login (用户名, 密码)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    API-&gt;&gt;API: 验证用户凭证</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    API-&gt;&gt;API: 生成 access_token (24h) 和 refresh_token (30d)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    API-&gt;&gt;Client: 设置 access_token 和 refresh_token Cookie</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    API-&gt;&gt;Redis: SET user_current_session:{user_id} = access_token, EXPIRE 25h</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    API--&gt;&gt;Client: 返回成功响应</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    </span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    Note over API,Redis: 用户登录成功，服务端记录令牌状态</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    </span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    Client-&gt;&gt;API: DELETE /user/logout</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    API-&gt;&gt;Redis: DEL user_current_session:{user_id}</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    API-&gt;&gt;API: 调用 unset_jwt_cookies()</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    API--&gt;&gt;Client: 清除 Cookie 并返回成功</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    </span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    Note over API,Redis: 用户登出，服务端主动使令牌失效</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&lt;/\`</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">**Diagram sources**</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">- [user.py](https://github.com/Shy2593666979/AgentChat/src/backend/agentchat/api/v1/user.py#L75)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">- [constants.py](https://github.com/Shy2593666979/AgentChat/src/backend/agentchat/utils/constants.py#L12)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">- [JWT.py](https://github.com/Shy2593666979/AgentChat/src/backend/agentchat/utils/JWT.py#L7)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">- [redis.py](https://github.com/Shy2593666979/AgentChat/src/backend/agentchat/services/redis.py#L41)</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">**Section sources**</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">- [user.py](https://github.com/Shy2593666979/AgentChat/src/backend/agentchat/api/v1/user.py#L51-L77)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">- [redis.py](https://github.com/Shy2593666979/AgentChat/src/backend/agentchat/services/redis.py#L41-L52)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">- [constants.py](https://github.com/Shy2593666979/AgentChat/src/backend/agentchat/utils/constants.py#L12)</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">## 混合认证模式分析</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">AgentChat系统采用的“无状态JWT + 有状态Redis缓存”是一种典型的混合认证模式，它巧妙地结合了两种模式的优势。</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">**优势分析：**</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">1.  **支持主动失效**：这是最核心的优势。通过在Redis中维护令牌的“影子”记录，系统可以主动删除该记录来使令牌失效，实现了用户登出、强制下线、密码修改后自动登出等关键安全功能。</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">2.  **保持无状态性**：对于绝大多数API请求，系统仍然依赖无状态的JWT进行认证，无需查询数据库或缓存，保证了高性能和可扩展性。</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">3.  **增强安全性**：使用HTTP Only Cookie存储令牌，有效防止了JavaScript访问，降低了XSS攻击的风险。同时，刷新令牌的长期有效性被限制在安全的Cookie中。</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">4.  **灵活的过期策略**：通过让Redis记录比JWT多存活一小时，系统为令牌刷新流程提供了缓冲时间。即使在刷新令牌的请求中，旧的访问令牌已过期，只要Redis记录仍在，服务端仍可验证其有效性并颁发新令牌。</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">**潜在挑战：**</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">1.  **缓存依赖**：系统引入了对Redis的强依赖。如果Redis服务不可用，将影响用户的登录和登出功能。</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">2.  **数据一致性**：需要确保Redis缓存与JWT状态的一致性。虽然当前设计通过过期时间的错开来缓解，但仍需考虑网络分区等极端情况下的数据不一致问题。</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">3.  **内存开销**：每个活跃用户都会在Redis中占用一个键值对，对于大规模用户系统，这会带来一定的内存开销。</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">## 系统架构影响</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">这种混合认证模式对AgentChat的系统架构产生了深远的影响。</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">首先，它将认证逻辑从纯粹的无状态服务转变为一个需要外部状态存储（Redis）的有状态服务。这要求在部署时必须配置和维护Redis实例，并确保其高可用性。</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">其次，它改变了API的认证流程。虽然大部分API仍可直接验证JWT，但一些关键操作（如登出）必须与Redis交互。这在架构图上体现为API服务器与Redis服务器之间存在直接的依赖关系。</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">最后，这种设计为未来的功能扩展奠定了基础。例如，可以轻松地在Redis中存储更多会话信息（如登录IP、设备信息），以实现更复杂的会话管理和安全审计功能。同时，它也为实现单点登录（SSO）或多设备管理提供了可能性，因为服务端可以精确地掌握每个用户的活跃会话。</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">**Section sources**</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">- [redis.py](https://github.com/Shy2593666979/AgentChat/src/backend/agentchat/services/redis.py)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">- [user.py](https://github.com/Shy2593666979/AgentChat/src/backend/agentchat/api/v1/user.py)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">- [auth_jwt.py](https://github.com/Shy2593666979/AgentChat/src/backend/fastapi_jwt_auth/auth_jwt.py)</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br><span class="line-number">25</span><br><span class="line-number">26</span><br><span class="line-number">27</span><br><span class="line-number">28</span><br><span class="line-number">29</span><br><span class="line-number">30</span><br><span class="line-number">31</span><br><span class="line-number">32</span><br><span class="line-number">33</span><br><span class="line-number">34</span><br><span class="line-number">35</span><br><span class="line-number">36</span><br><span class="line-number">37</span><br><span class="line-number">38</span><br><span class="line-number">39</span><br><span class="line-number">40</span><br><span class="line-number">41</span><br><span class="line-number">42</span><br><span class="line-number">43</span><br><span class="line-number">44</span><br><span class="line-number">45</span><br><span class="line-number">46</span><br><span class="line-number">47</span><br><span class="line-number">48</span><br><span class="line-number">49</span><br><span class="line-number">50</span><br><span class="line-number">51</span><br><span class="line-number">52</span><br><span class="line-number">53</span><br><span class="line-number">54</span><br><span class="line-number">55</span><br><span class="line-number">56</span><br><span class="line-number">57</span><br><span class="line-number">58</span><br><span class="line-number">59</span><br><span class="line-number">60</span><br></div></div>`,17)])])}const d=a(p,[["render",l]]);export{b as __pageData,d as default};
